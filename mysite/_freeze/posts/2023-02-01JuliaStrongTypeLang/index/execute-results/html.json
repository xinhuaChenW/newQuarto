{
  "hash": "8ceb13b3c098f44cdfa6cb14a9210fe0",
  "result": {
    "markdown": "---\ntitle: 从push!()看julia强类型语言特性\ntitle-block-banner: '#00165f'\nauthor:\n  - name: Chen Xinhua\n    url: 'https://github.com/xinhuaChenW'\n    orcid: 0000-0002-4930-7375\n    affiliation: Ph.D. candidate of Forest Tree Genetics and Breeding @ Chinese Academy of Forestry\ndate: 2/01/2023\ncategories:\n  - Julia\n  - Array\n  - Vector\nformat:\n  html:\n    code-fold: false\n---\n\n总说julia是强类型语言，但是原来感受不是很深，直到用到push!()。\n\n按一般的理解push!()函数可以向vector里添加元素，如，\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nhaystack = [\"abc\",\"abc\",\"xyz\",\"opq\",\"rst\",\"def\",\"ghk\",\"ccc\"]\nneedle = \"a\"\npush!(haystack,needle)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n9-element Vector{String}:\n \"abc\"\n \"abc\"\n \"xyz\"\n \"opq\"\n \"rst\"\n \"def\"\n \"ghk\"\n \"ccc\"\n \"a\"\n```\n:::\n:::\n\n\n但如果needle有两个元素，push!()就不行，\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nhaystack = [\"abc\",\"abc\",\"xyz\",\"opq\",\"rst\",\"def\",\"ghk\",\"ccc\"]\nneedle = [\"a\",\"c\"]\npush!(haystack,needle)\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: MethodError: \u001b[0mCannot `convert` an object of type \u001b[92mVector{String}\u001b[39m\u001b[0m to an object of type \u001b[91mString\u001b[39m\n\u001b[0mClosest candidates are:\n\u001b[0m  convert(::Type{String}, \u001b[91m::String\u001b[39m) at essentials.jl:218\n\u001b[0m  convert(::Type{T}, \u001b[91m::T\u001b[39m) where T<:AbstractString at strings/basic.jl:231\n\u001b[0m  convert(::Type{T}, \u001b[91m::AbstractString\u001b[39m) where T<:AbstractString at strings/basic.jl:232\n\u001b[0m  ...\n```\n:::\n:::\n\n\n其实，问题的本质不在于needle元素的多少，而在于needle的类型，即使needle只有一个元素，但如果类型是Vector{String}，那样也不行，如下：\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nhaystack = [\"abc\",\"abc\",\"xyz\",\"opq\",\"rst\",\"def\",\"ghk\",\"ccc\"] # 8-element Vector{String}\npush!(haystack,needle)\nneedle = [\"a\"] # 1-element Vector{String}\npush!(haystack,needle)\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: MethodError: \u001b[0mCannot `convert` an object of type \u001b[92mVector{String}\u001b[39m\u001b[0m to an object of type \u001b[91mString\u001b[39m\n\u001b[0mClosest candidates are:\n\u001b[0m  convert(::Type{String}, \u001b[91m::String\u001b[39m) at essentials.jl:218\n\u001b[0m  convert(::Type{T}, \u001b[91m::T\u001b[39m) where T<:AbstractString at strings/basic.jl:231\n\u001b[0m  convert(::Type{T}, \u001b[91m::AbstractString\u001b[39m) where T<:AbstractString at strings/basic.jl:232\n\u001b[0m  ...\n```\n:::\n:::\n\n\n也同样报错。\n\n为什么？\n因为haystack是一个Vector{String}类型，它要求Vector里的元素是String，才可以添加，至于为什么是Vector{String}类型，这是Julia的类型推断系统决定的。\n因此，当needle是String类型的时候，可以被push!到Vector{String}中，\n也即，添加元素的类型要与目标容器内部的元素类型保持一致。而不在于添加的元素个数，如，\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\npsh1 = [[\"a\",\"b\"],[\"c\",\"d\"],[\"e\",\"f\"]] # 3-element Vector{String}\n\npsh2 = [\"x\",\"y\"] # 2-element Vector{String}\n\npush!(psh1,psh2)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n4-element Vector{Vector{String}}:\n [\"a\", \"b\"]\n [\"c\", \"d\"]\n [\"e\", \"f\"]\n [\"x\", \"y\"]\n```\n:::\n:::\n\n\npsh1的元素类型是Vector{String}因此，psh2作为相同的类型，可以被push。\n\n最重要的是类型，而不是元素个数。\n当然，你也可以理解成psh2看成一个整体，它就只含有一个元素，但这不是本质。\n况且，你看psh2是否为整体，也是要基于它的类型。\n总之，要多留心对象的类型。\n\n其实julia的mannual里将push!()定义得很好了，\n\n![](Image.png)\npush!()是添加item或items到collection里。\n因此，items类型要与collection里的item类型一致。\n\n而相比之，append!()是添加另一个collection里的所有元素到另一个collection里。\n因此，两个函数对待item的方式不一样，push!()看整体，append!()把collection拆开一层（只要是可迭代对象），因此，才会有append!(A,\"abc\")，得到的是拆开的\"a\",\"b\",\"c\".\n \n 而且注意，append!()即使失败，也会在目标对象中添加\"#undef\"元素。\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\npsh1 = [[\"a\",\"b\"],[\"c\",\"d\"],[\"e\",\"f\"]] # 3-element Vector{String}\n\npsh2 = [\"x\",\"y\"] # 2-element Vector{String}\n\nappend!(psh1,psh2)\n\nprintln(psh1)\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: MethodError: \u001b[0mCannot `convert` an object of type \u001b[92mString\u001b[39m\u001b[0m to an object of type \u001b[91mVector{String}\u001b[39m\n\u001b[0mClosest candidates are:\n\u001b[0m  convert(::Type{T}, \u001b[91m::LinearAlgebra.Factorization\u001b[39m) where T<:AbstractArray at D:\\Program Files\\Julia-1.8.4\\share\\julia\\stdlib\\v1.8\\LinearAlgebra\\src\\factorization.jl:58\n\u001b[0m  convert(::Type{Vector{String}}, \u001b[91m::LibGit2.StrArrayStruct\u001b[39m) at D:\\Program Files\\Julia-1.8.4\\share\\julia\\stdlib\\v1.8\\LibGit2\\src\\strarray.jl:13\n\u001b[0m  convert(::Type{T}, \u001b[91m::AbstractArray\u001b[39m) where T<:Array at array.jl:617\n\u001b[0m  ...\n```\n:::\n:::\n\n\n多个两个元素#undef。\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}